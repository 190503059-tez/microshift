#!/usr/bin/env python3
# pylint: disable=too-many-locals, line-too-long

"""Release Note Tool

This script partially automates the process of publishing release
notes for engineering candidate and release candidate builds of
MicroShift.

The script expects to be run in multiple phases.

*Tagging*

First, it looks for the most recent RPM to have been published to the
mirror, and uses information encoded in that filename to determine the
SHA of the commit that was used for the build and the version number
given to it.

Then it looks for that tag in the local repository. If there is no tag
already, it emits instructions for tagging the correct commit and
pushing the tag to GitHub.

*Draft Release*

After the tag is present, running the script again causes it to use gh
to produce a draft release with a preamble that includes download URLs
and a body that is auto-generated by GitHub's service based on the
pull requests that have merged since the last tagged release.

*Publishing Release*

The script creates a draft release, which must be published by hand to
make it public. Open the link printed at the end of the script run and
use the web interface to review and then publish the release.

NOTE:

  To use this script, you must have the GitHub command line tool "gh"
  installed and you must have enough privileges on the
  openshift/microshift repository to create releases.

"""

import argparse
import re
import subprocess
import textwrap
from urllib import request

VERSION="4.13"
URL_BASE="https://mirror.openshift.com/pub/openshift-v4/aarch64/microshift"
URL_BASE_X86="https://mirror.openshift.com/pub/openshift-v4/x86_64/microshift"

# An EC RPM filename looks like
# microshift-4.13.0~ec.4-202303070857.p0.gcf0bce2.assembly.ec.4.el9.aarch64.rpm
# an RC RPM filename looks like
# microshift-4.13.0~rc.0-202303212136.p0.gbd6fb96.assembly.rc.0.el9.aarch64.rpm
VERSION_RE = re.compile(
    r"""
    microshift-      # prefix
    (?P<product_version>\d+\.\d+\.\d+)    # product version
    ~                # separator
    (?P<candidate_type>ec|rc)\.(?P<candidate_number>\d+)  # which candidate of which type
    -
    (?P<release_date>\d+)\.            # date
    p(?P<patch_num>\d+)\.           # patch number
    g(?P<commit_sha>[\dabcdef]+)\.   # commit SHA prefix
    """,
    re.VERBOSE,
)


def main():
    """
    The main function of the script. It runs the `check_one()` function for both 'ocp-dev-preview'
    and 'ocp' release types and for a specified version depending upon provided arguments.
    """
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        '-v', '--version',
        action='store',
        help='Specify the MicroShift major and minor version. (Default: %(default)s)',
        dest='version',
        default=VERSION,
    )
    parser.add_argument(
        '--ec',
        action='store_true',
        default=True,
        dest='ec',
        help='Include engineering candidates (default)',
    )
    parser.add_argument(
        '--no-ec',
        action='store_false',
        dest='ec',
        help='Do not include engineering candidates',
    )
    parser.add_argument(
        '--rc',
        action='store_true',
        default=True,
        help='Include release candidates (default)',
    )
    parser.add_argument(
        '--no-rc',
        action='store_false',
        dest='rc',
        help='Do not include release candidates',
    )
    args = parser.parse_args()
    if args.ec:
        check_one('ocp-dev-preview', args.version)
    if args.rc:
        check_one('ocp', args.version)


def check_one(release_type, version):
    """
    Checks the latest RPMs for a given release type and version,
    and emits instructions for creating the release and tag, if they don't exist.
    """
    # Get the list of the latest RPMs for the release type and vbersion.
    rpm_list_url = f"{URL_BASE}/{release_type}/latest-{version}/el9/os/rpm_list"
    print(f"\nFetching {rpm_list_url} ...")
    with request.urlopen(rpm_list_url) as rpm_list_response:
        rpm_list = rpm_list_response.read().decode("utf-8").splitlines()

    # Look for the RPM for MicroShift itself, with a name like
    #
    # Packages/microshift-4.13.0~ec.3-202302130757.p0.ge636e15.assembly.ec.3.el8__aarch64/microshift-4.13.0~ec.3-202302130757.p0.ge636e15.assembly.ec.3.el8.aarch64.rpm
    #
    # then parse out the EC version number and other details needed to
    # build the release tag.
    microshift_rpm_name_prefix=f"microshift-{version}"
    microshift_rpm_filename = None
    for package_path in rpm_list:
        parts = package_path.split("/")
        if parts[-1].startswith(microshift_rpm_name_prefix):
            microshift_rpm_filename = parts[-1]
            break
    else:
        raise RuntimeError(f"Did not find {microshift_rpm_name_prefix} in {rpm_list}")

    print(f"Examining RPM {microshift_rpm_filename}")

    match = VERSION_RE.search(microshift_rpm_filename)
    if match is None:
        raise RuntimeError(f"Could not parse version info from '{microshift_rpm_filename}'")
    rpm_version_details = match.groupdict()
    product_version = rpm_version_details["product_version"]
    candidate_type = rpm_version_details["candidate_type"]
    candidate_number = rpm_version_details["candidate_number"]
    commit_sha = rpm_version_details["commit_sha"]

    # To be consistent with past releases, the release name should
    # look like: 4.13.0-ec-2
    release_name = "-".join([
        product_version,
        candidate_type,
        candidate_number,
    ])

    # Check if the release already exists
    print(f"Checking for release {release_name}...")
    try:
        subprocess.run(["gh", "release", "view", release_name],
                       check=True,
                       stdout=subprocess.DEVNULL,
                       stderr=subprocess.DEVNULL,
                       )
    except subprocess.CalledProcessError:
        print("Not found")
    else:
        print("Found an existing release, no work to do")
        return

    # Check for the tag to be present in the local git repository
    try:
        subprocess.run(["git", "show", release_name],
                       stdout=subprocess.DEVNULL,
                       stderr=subprocess.DEVNULL,
                       check=True)
        print(f"Found tag for {release_name}")
    except subprocess.CalledProcessError:
        print(f"Tag {release_name} on commit {commit_sha} by running:")
        print("")
        print(f"git tag -s -m '{product_version} {candidate_type.upper()} {candidate_number}' {release_name} {commit_sha}")
        print(f"git push origin {release_name}")
        return

    # Set up the release notes preamble with download links
    notes = textwrap.dedent(f"""
    This is a candidate release for {product_version}.

    See the mirror for build artifacts:
    - {URL_BASE_X86}/{release_type}/{product_version}-{candidate_type}.{candidate_number}/
    - {URL_BASE}/{release_type}/{product_version}-{candidate_type}.{candidate_number}/

    """)

    # Create draft release with message that includes download URLs and history
    try:
        subprocess.run(["gh", "release", "create",
                        "--draft",
                        "--prerelease",
                        "--notes", notes,
                        "--generate-notes",
                        release_name,
                        ],
                       check=True)
    except subprocess.CalledProcessError as err:
        print(f"Failed to create the release: {err}")
        return


if __name__ == "__main__":
    main()
